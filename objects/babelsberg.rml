(* file assignment.rml *)

module babelsberg:
(* Abstract syntax for the BabelsbergP language *)

  datatype Program = PROGRAM of Statement

  datatype Statement = SKIP
		     | ASSIGN of LValue * Exp
		     | ALWAYS of Constraint
		     | ONCE of Constraint
		     | SEQ of Statement * Statement
		     | IF of Exp * Statement * Statement
		     | WHILE of Exp * Statement

  datatype Constraint = CONSTRAINT of Rho * Exp
		      | COMPOUNDCONSTRAINT of Constraint * Constraint

  datatype Rho = WEAK | MEDIUM | REQUIRED

  datatype Exp = VALUE of Value
	       | LVALUE of LValue
	       | OP of Exp * Op * Exp
	       | COMPARE of Exp * Comp * Exp
	       | COMBINE of Exp * Comb * Exp
	       | IDENTITY of Exp * Exp
	       | CALL of Exp * Label * Exp list
	       | IRECORD of ObjectLiteral
	       | UIDRECORD of ObjectLiteral
	       | DEREF of Dereference

  type ObjectLiteral = (Label * Exp) list

  datatype LValue = VARIABLE of Variable | FIELD of Exp * Label
		  | ASSIGNDEREF of Dereference (* just for the parsing *)

  datatype Constant = TRUE | FALSE | NIL | REAL of real | STRING of string

  type Variable = string

  type Label = string

  type Reference = int

  type Dereference = Exp

  datatype MethodBody = METHOD of Statement * Exp | SIMPLE of Exp

  datatype Value = K of Constant | O of ObjectLiteral | R of Reference

(* Helper types *)
  datatype Op =  ADD | SUB | MUL | DIV
  datatype Comp = LESSTHAN | LEQUAL | EQUAL | NEQUAL | GEQUAL | GREATERTHAN
  datatype Comb = AND | OR

(* Type syntax *)
  datatype Type = PRIMITIVE | TRECORD of (Label * Type) list

(* Bindings and environments *)
  type Env         = (Variable * Value) list
  type Scope       = (Variable * Variable) list
  type Heap        = (Reference * ObjectLiteral) list
  type Cstore      = (Scope * Constraint) list
  type Istore      = (Scope * Constraint) list

  relation evalprogram: Program => ()
  relation eval: (Env, Scope, Heap, Cstore, Istore, Exp) => (Env, Heap, Cstore, Istore, Value)

  relation alert: (string list, Exp list, string list) => ()
end

relation evalprogram: Program => () =
  rule print "starting to evaluate\n" &
       step([], [], [], [], [], statement) => (E,S,H,C,I)
       --------------------------------------------------
       evalprogram(PROGRAM(statement))
end

relation lookup: (Value, Label) => (Variable list, MethodBody) =
  (* hard coded methods *)
  axiom lookup(_, "one") => ([], (* return 1.0 *)
			  SIMPLE(VALUE(K(REAL(1.0)))))

  axiom lookup(_, "double") => ([], (* return 2*self *)
			  SIMPLE(OP(VALUE(K(REAL(2.0))),MUL,LVALUE(VARIABLE("self")))))

  axiom lookup(_, "Require_min_balance") => (["acct","min"], (* always acct.balance > min *)
			  METHOD(ALWAYS(CONSTRAINT(REQUIRED, COMPARE(LVALUE(FIELD(LVALUE(VARIABLE("acct")),"balance")),
								     GREATERTHAN,
								     LVALUE(VARIABLE("min?"))))),
				 LVALUE(VARIABLE("self"))))

  axiom lookup(_, "Has_min_balance") => (["acct","min"], (* return acct.balance > min *)
			  SIMPLE(COMPARE(LVALUE(FIELD(LVALUE(VARIABLE("acct")),"balance")),
					 GREATERTHAN,
					 LVALUE(VARIABLE("min")))))

  (* {x: arg1, y: arg2} *)
  axiom lookup(_, "Point") => (["x", "y"],
				SIMPLE(IRECORD([("x", LVALUE(VARIABLE("x"))),
						("y", LVALUE(VARIABLE("y")))])))

  (* (self.upper_left.addPt(self.lower_right).divPtScalar(2) *)
  axiom lookup(_, "center") => ([],
				SIMPLE(CALL(CALL(LVALUE(FIELD(LVALUE(VARIABLE("self")), "upper_left")),
						 "addPt",
						 [LVALUE(FIELD(LVALUE(VARIABLE("self")), "lower_right"))]),
					    "divPtScalar",
					    [VALUE(K(REAL(2.0)))])))

  (* {x: self.x + pt.x, y: self.y + pt.y} *)
  axiom lookup(_, "addPt") => (["pt"],
				SIMPLE(CALL(VALUE(K(NIL)),
					    "Point",
					    [OP(LVALUE(FIELD(LVALUE(VARIABLE("self")),"x")),
						ADD,
						LVALUE(FIELD(LVALUE(VARIABLE("pt")),"x"))),
					     OP(LVALUE(FIELD(LVALUE(VARIABLE("self")),"y")),
						ADD,
						LVALUE(FIELD(LVALUE(VARIABLE("pt")),"y")))])))

  (* {x: self.x / scale, y: self.y / scale} *)
  axiom lookup(_, "divPtScalar") => (["scale"],
				     SIMPLE(CALL(VALUE(K(NIL)),
						 "Point",
						 [OP(LVALUE(FIELD(LVALUE(VARIABLE("self")),"x")),
						     DIV,
						     LVALUE(VARIABLE("scale"))),
						  OP(LVALUE(FIELD(LVALUE(VARIABLE("self")),"y")),
						     DIV,
						     LVALUE(VARIABLE("scale")))])))

  (* {x: self.x + pt.x, y: self.y + pt.y} *)
  axiom lookup(_, "ptEq") => (["other"],
				SIMPLE(COMBINE(COMPARE(LVALUE(FIELD(LVALUE(VARIABLE("self")),"x")),
						       EQUAL,
						       LVALUE(FIELD(LVALUE(VARIABLE("other")),"x"))),
					       AND,
					       COMPARE(LVALUE(FIELD(LVALUE(VARIABLE("self")),"y")),
						       EQUAL,
						       LVALUE(FIELD(LVALUE(VARIABLE("other")),"y"))))))

  (* always medium i = 5; return i + 1 *)
  axiom lookup(_, "Test") => (["i"],
			      METHOD(ALWAYS(CONSTRAINT(MEDIUM, COMPARE(LVALUE(VARIABLE("i")),EQUAL,VALUE(K(REAL(5.0)))))),
				     OP(LVALUE(VARIABLE("i")),ADD,VALUE(K(REAL(1.0))))))

  (* 
   * axiom lookup(_, "ArrayNew2") => ([],
   * 				   SIMPLE(IRECORD([("length", VALUE(K(REAL(2.0)))),
   * 						   ("i0", VALUE(K(NIL))),
   * 						   ("i1", VALUE(K(NIL)))])))
   * 
   * axiom lookup(_, "sum") => ([],
   * 			     METHOD(SEQ(ASSIGN(VARIABLE("ans"), VALUE(K(REAL(0.0)))),
   * 					SEQ(ASSIGN(VARIABLE("i"), VALUE(K(REAL(0.0)))),
   * 					    WHILE(COMPARE(LVALUE(VARIABLE("i")),LESSTHAN,LVALUE(FIELD(LVALUE(VARIABLE("self")), "length"))),
   * 						  SEQ(ASSIGN(VARIABLE("ans"), VALUE(K(REAL(0.0))))
   *)

  axiom lookup(_, "MutablePointNew") => (["x", "y"],
					 SIMPLE(UIDRECORD([("x", LVALUE(VARIABLE("x"))),
							   ("y", LVALUE(VARIABLE("y")))])))

  axiom lookup(_, "WindowNew") => ([],
				   SIMPLE(UIDRECORD([("window", VALUE(K(TRUE)))])))

  axiom lookup(_, "CircleNew") => ([],
				   SIMPLE(UIDRECORD([("circle", VALUE(K(TRUE)))])))


  axiom lookup(_, "Makeeq") => (["x","y"],
				METHOD(ALWAYS(CONSTRAINT(REQUIRED,
							 IDENTITY(LVALUE(VARIABLE("x")),LVALUE(VARIABLE("y"))))),
				       LVALUE(VARIABLE("self"))))

  axiom lookup(_, "MakeIdentical") => (["a","b"],
				METHOD(ALWAYS(CONSTRAINT(REQUIRED,
							 IDENTITY(LVALUE(VARIABLE("a")),LVALUE(VARIABLE("b"))))),
				       LVALUE(VARIABLE("self"))))

  axiom lookup(_, "Testalwaysxequal5") => (["x"],
				METHOD(ALWAYS(CONSTRAINT(REQUIRED,
							 COMPARE(LVALUE(VARIABLE("x")),EQUAL,VALUE(K(REAL(5.0)))))),
				       LVALUE(VARIABLE("x"))))

  axiom lookup(_, "Testalwaysaequalsbplus3") => (["a", "b"],
				METHOD(ALWAYS(CONSTRAINT(REQUIRED,
							 COMPARE(LVALUE(VARIABLE("a")),EQUAL,OP(LVALUE(VARIABLE("b")),ADD,VALUE(K(REAL(3.0))))))),
				       LVALUE(VARIABLE("a"))))

  axiom lookup(_, "Testpointxequals5") => (["p"],
				METHOD(ALWAYS(CONSTRAINT(REQUIRED,
							 COMPARE(LVALUE(FIELD(LVALUE(VARIABLE("p")),"x")),EQUAL,VALUE(K(REAL(5.0)))))),
				       LVALUE(VARIABLE("p"))))

  axiom lookup(_, "TestXGetsXPlus3ReturnX") => (["x"],
				METHOD(ASSIGN(VARIABLE("x"),OP(LVALUE(VARIABLE("x")),ADD,VALUE(K(REAL(3.0))))),
				       LVALUE(VARIABLE("x"))))

end

relation enter: (Env, Scope, Heap, Cstore, Istore, Value, Variable list, Exp list) => (Env, Scope, Heap, Cstore, Istore) =
  rule evalEach(E, S, H, C, I, argexps) => (En, Hn, Cn, In, argvals) &
       assignEachFresh(En, [], Hn, Cn, In, "self" :: argnames, v :: argvals) => (E2n, Sn, Hn, Cn, In)
       ----------------------------------------------------------------------------------------------
       enter(E, S, H, C, I, v, argnames, argexps) => (E2n, Sn, Hn, Cn, In)
end

relation evalEach: (Env, Scope, Heap, Cstore, Istore, Exp list) => (Env, Heap, Cstore, Istore, Value list) =
  axiom	evalEach(E,S,H,C,I,[]) => (E,H,C,I,[])

  rule	eval(E,S,H,C,I,e) => (E',H',C',I',v) &
	evalEach(E',S,H',C',I',rest) => (E'',H'',C'',I'',values)
	------------------------------------------------------
	evalEach(E,S,H,C,I,e :: rest) => (E'',H'',C'',I'',v :: values)
end

relation assignEachFresh: (Env, Scope, Heap, Cstore, Istore, Variable list, Value list) => (Env, Scope, Heap, Cstore, Istore) =
  axiom	assignEachFresh(E,S,H,C,I,[],[]) => (E,S,H,C,I)

  rule	tick() => i & int_string(i) => is & string_append(x,is) => xg &
	list_append(S,[(x,xg)]) => S' &
	list_append(E,[(xg,v)]) => E' &
	assignEachFresh(E',S',H,C,I,xrest, vrest) => (E'',S'',H,C,I)
	------------------------------------------------------------
	assignEachFresh(E,S,H,C,I,x :: xrest, v :: vrest) => (E'',S'',H,C,I)
end

relation eval: (Env, Scope, Heap, Cstore, Istore, Exp) => (Env, Heap, Cstore, Istore, Value) =
  axiom eval(E,S,H,C,I,VALUE(K(c))) => (E,H,C,I,K(c))

  rule	alert(["E-Var(", x],[],[")\n"]) &
	Util.lookupScope(S, x) => xg & Util.lookupEnv(E, xg) => v
	---------------------------------------------------------
	eval(E,S,H,C,I, LVALUE(VARIABLE(x))) => (E,H,C,I,v)

  rule	eval(E,S,H,C,I,e) => (E',H',C',I',R(r)) &
	alert(["E-Field(", l, ")\n"], [], []) &
	Util.lookupHeap(H', r) => fvalues &
	Util.lookupRecord(fvalues, l) => v
	----------------------------------
	eval(E,S,H,C,I, LVALUE(FIELD(e, l))) => (E',H',C',I',v)

  rule	eval(E,S,H,C,I,e) => (E',H',C',I',O(fvalues)) &
	alert(["E-ValueField(", l, ")"], [], []) &
	Util.lookupRecord(fvalues, l) => v
	----------------------------------
	eval(E,S,H,C,I, LVALUE(FIELD(e, l))) => (E',H',C',I',v)

  axiom	eval(E,S,H,C,I, VALUE(R(r))) => (E,H,C,I, R(r))

  rule alert(["E-Op\n"],[],[]) &
       eval(E,S,H,C,I,e1) => (E',H',C',I',v1) &
       eval(E',S,H',C',I',e2) => (E'',H'',C'',I'',v2) &
       Util.apply_binop(op,v1,v2) => v
       -------------------------------
       eval(E,S,H,C,I, OP(e1, op, e2)) => (E'',H'',C'',I'',v)

  rule alert(["E-Compare\n"],[],[]) &
       eval(E,S,H,C,I,e1) => (E',H',C',I',v1) &
       eval(E',S,H',C',I',e2) => (E'',H'',C'',I'',v2) &
       Util.apply_bincomp(op,v1,v2) => v
       ---------------------------------
       eval(E,S,H,C,I, COMPARE(e1, op, e2)) => (E'',H'',C'',I'',v)

  rule eval(E,S,H,C,I,e1) => (E',H',C',I',v1) &
       Util.shortcircuit_bincomb(op,v1) => (true, v) &
       alert(["E-CombineShortCircuit\n"],[],[])
       -------------------------------
       eval(E,S,H,C,I, COMBINE(e1, op, e2)) => (E',H',C',I',v1)

  rule alert(["E-Combine\n"],[],[]) &
       eval(E,S,H,C,I,e1) => (E',H',C',I',v1) &
       Util.shortcircuit_bincomb(op,v1) => (false, v) &
       eval(E',S,H',C',I',e2) => (E'',H'',C'',I'',v2) &
       Util.apply_bincomb(op,v1,v2) => v
       ---------------------------------
       eval(E,S,H,C,I, COMBINE(e1, op, e2)) => (E'',H'',C'',I'',v1)

  rule eval(E,S,H,C,I,e1) => (E',H',C',I',v1) &
       eval(E',S,H',C',I',e2) => (E'',H'',C'',I'',v2) &
       v1 = v2 &
       alert(["E-IdentityTrue\n"],[],[])
       ------------------------
       eval(E,S,H,C,I, IDENTITY(e1, e2)) => (E'',H'',C'',I'',K(TRUE))

  rule eval(E,S,H,C,I,e1) => (E',H',C',I',v1) &
       eval(E',S,H',C',I',e2) => (E'',H'',C'',I'',v2) &
       not v1 = v2 &
       alert(["E-IdentityFalse\n"],[],[])
       ------------------------
       eval(E,S,H,C,I, IDENTITY(e1, e2)) => (E'',H'',C'',I'',K(FALSE))

  rule	eval(E,S,H,C,I,e) => (E0,H0,C0,I0,v) &
	lookup(v,l) => (argnames, METHOD(s, returne)) &
	alert(["E-Call\n"],[],[]) &
	enter(E0,S,H0,C0,I0,v,argnames,argexps) => (E1,Sm,H1,C1,I1) &
	step(E1,Sm,H1,C1,I1,s) => (E',S',H',C',I') &
	eval(E',S',H',C',I',returne) => (E'',H'',C'',I'',vr)
	----------------------------------------------
	eval(E,S,H,C,I,CALL(e,l,argexps)) => (E'',H'',C'',I'',vr)

  rule	alert(["E-CallSimple\n"],[],[]) &
	eval(E,S,H,C,I,e) => (E0,H0,C0,I0,v) &
	lookup(v,l) => (argnames, SIMPLE(returne)) &
	enter(E0,S,H0,C0,I0,v,argnames,argexps) => (E1,Sm,H1,C1,I1) &
	eval(E1,Sm,H1,C1,I1,returne) => (E',H',C',I',vr)
	----------------------------------------------
	eval(E,S,H,C,I,CALL(e,l,argexps)) => (E',H',C',I',vr)

  rule	alert(["E-New\n"],[],[]) &
	evalEachField(E,S,H,C,I,fieldexps) => (En,Hn,Cn,In,fieldvalues) &
	tick() => r &
	list_append([(r, fieldvalues)], Hn) => H'
	------------------------------------------------------------------
	eval(E,S,H,C,I,UIDRECORD(fieldexps)) => (En,H',Cn,In,R(r))

  rule	alert(["E-Value\n"],[],[]) &
	evalEachField(E,S,H,C,I,fieldexps) => (En,Hn,Cn,In,fieldvalues)
	------------------------------------------------------------------
	eval(E,S,H,C,I,IRECORD(fieldexps)) => (En,Hn,Cn,In,O(fieldvalues))
end

relation evalEachField: (Env, Scope, Heap, Cstore, Istore, ObjectLiteral) => (Env, Heap, Cstore, Istore, ObjectLiteral) =
  axiom	evalEachField(E,S,H,C,I,[]) => (E,H,C,I,[])

  rule	eval(E,S,H,C,I,e) => (E',H',C',I',v) &
	evalEachField(E',S,H',C',I',rest) => (E'',H'',C'',I'',values)
	------------------------------------------------------
	evalEachField(E,S,H,C,I,(l,e) :: rest) => (E'',H'',C'',I'',(l,VALUE(v)) :: values)
end

relation tC: (Env, Heap, Exp) => Type =
  axiom tC(E, H, VALUE(K(c))) => PRIMITIVE

  rule	alert(["T-Var\n"],[],[]) &
	Util.lookupEnv(E, x) => v &
	tC(E,H,VALUE(v)) => T
	---------------------------------
	tC(E,H, LVALUE(VARIABLE(x))) => T

  rule alert(["T-Field\n"],[],[]) &
       tC(E,H,e) => TRECORD(ftypes) &
       Util.lookupRecordType(ftypes, l) => T
       -------------------------------------
       tC(E,H, LVALUE(FIELD(e, l))) => T

  rule	alert(["T-Ref\n"],[],[]) &
	Util.lookupHeap(H, r) => fvalues &
	tC(E,H,VALUE(O(fvalues))) => T
	------------------------------
	tC(E,H,VALUE(R(r))) => T

  rule	alert(["T-Op\n"],[],[]) &
	tC(E,H,e1) => PRIMITIVE &
	tC(E,H,e2) => PRIMITIVE
	--------------------------
	tC(E,H, OP(e1, op, e2)) => PRIMITIVE

  rule alert(["T-Compare\n"],[],[]) &
       tC(E,H,e1) => T1 &
       tC(E,H,e2) => T2 &
       T1 = T2
       --------------------------
       tC(E,H, COMPARE(e1, op, e2)) => PRIMITIVE

  rule alert(["T-Combine\n"],[],[]) &
       tC(E,H,e1) => PRIMITIVE &
       tC(E,H,e2) => PRIMITIVE
       --------------------------
       tC(E,H, COMBINE(e1, op, e2)) => PRIMITIVE

  rule alert(["T-ValueObject\n"],[],[]) &
       tCFields(E,H, fvalues) => ftypes
       ---------------------------------------
       tC(E,H, VALUE(O(fvalues))) => TRECORD(ftypes)

  rule alert(["T-Deref\n"],[],[]) &
       tC(E,H, e) => T
       ---------------------------------------
       tC(E,H, DEREF(e)) => T
end

relation tCFields: (Env, Heap, ObjectLiteral) => (Label * Type) list =
  axiom tCFields(E,H,[]) => []

  rule tC(E,H,e) => T &
       tCFields(E,H,rest) => ftypes
       ----------------------------
       tCFields(E,H, (l,e) :: rest) => ((l,T) :: ftypes)
end

relation welltyped: (Env, Heap, Constraint) => () =
  rule tC(E,H,e) => T
       ---------------------------
       welltyped(E,H, CONSTRAINT(rho, e))

  rule welltyped(E,H,C1) & welltyped(E,H,C2)
       -------------------------------------
       welltyped(E,H, COMPOUNDCONSTRAINT(C1, C2))
end

with "solver.rml"
with "printer.rml"
with "helper.rml"

relation models: Constraint => (Env, Heap) =
  rule Print.pRefDom(C) => refDom &
       Print.pLabDom(C) => labDom &
       Print.pDefs(C) => defs &
       Print.printC(C) => Cs &
       string_append_list(["(set-option :pp.decimal true)(set-option :model.compact true)\n",
			   refDom, "\n", labDom, "\n
; Next block of declarations are the same everywhere
; We use a Union type for values
(declare-datatypes (U T) ((Value (Real (real U))
                                 (Reference (ref T)))))
; A default record has 'invalid' for all fields
(declare-const iRec (Array Label (Value Real Reference)))
(assert (= iRec ((as const (Array Label (Value Real Reference))) (Reference invalid))))
; Records are (Array Label (Value Real Reference))
(declare-fun H ((Value Real Reference)) (Array Label (Value Real Reference)))
(assert (and (= (H (Reference invalid)) iRec) (= (H (Reference nil)) iRec)))
\n",
			   defs, "\n", Cs, "\n(check-sat)\n(get-model)\n"]) => srr &
       Solver.solve(srr) => El &
       print "\n" &
       Print.parseEnvironment(El, [], []) => (E, H) &
       print "\n"
       ------------------------------
       models(C) => (E, H)
end

relation stay: Env => Constraint =
  axiom stay([]) => CONSTRAINT(REQUIRED, VALUE(K(TRUE)))

  rule alert(["StayOne\n"],[],[]) &
       stay(E0) => C0
       --------------------------------
       stay((x, v) :: E0) => COMPOUNDCONSTRAINT(C0, CONSTRAINT(WEAK, COMPARE(LVALUE(VARIABLE(x)), EQUAL, VALUE(v))))
end

relation stayH: Heap => Constraint =
  axiom stayH([]) => CONSTRAINT(REQUIRED, VALUE(K(TRUE)))

  rule alert(["StayHeap\n"],[],[]) &
       stayFields(r, o) => (Cf, o') &
       stayH(H0) => C0
       --------------------------------
       stayH((r, o) :: H0) => COMPOUNDCONSTRAINT(C0,
				 COMPOUNDCONSTRAINT(CONSTRAINT(REQUIRED, COMPARE(DEREF(VALUE(R(r))), EQUAL, VALUE(O(o')))), Cf))
end

relation stayFields: (Reference, ObjectLiteral) => (Constraint, ObjectLiteral) =
  axiom stayFields(_, []) => (CONSTRAINT(REQUIRED, VALUE(K(TRUE))), [])

  rule stayFields(r, rest) => (C, o) &
       int_string(r) => is & string_append_list(["ref", is, "_", l]) => x
       -------------------------------------------------------------------------------
       stayFields(r, (l, e) :: rest) => (COMPOUNDCONSTRAINT(CONSTRAINT(WEAK, COMPARE(LVALUE(VARIABLE(x)), EQUAL, e)), C),
					 (l, LVALUE(VARIABLE(x))) :: o)
end

relation identityStay: Env => Constraint =
  axiom identityStay([]) => CONSTRAINT(REQUIRED, VALUE(K(TRUE)))

  rule alert(["StayRef\n"],[],[]) &
       identityStay(E0) => C0
       --------------------------------
       identityStay((x, R(r)) :: E0) => COMPOUNDCONSTRAINT(C0, CONSTRAINT(REQUIRED, COMPARE(LVALUE(VARIABLE(x)), EQUAL, VALUE(R(r)))))

  rule alert(["StayObj\n"],[],[]) & identityStay(E0) => C0 & stay([(x, O(o))]) => C1
       --------------------------------------------------------------------
       identityStay((x, O(o)) :: E0) => COMPOUNDCONSTRAINT(C0, C1)

  rule alert(["StayConst\n"],[],[]) & identityStay(E0) => C0 & stay([(x, K(c))]) => C1
       ----------------------------------------------------------------------
       identityStay((x, K(c)) :: E0) => COMPOUNDCONSTRAINT(C0, C1)
end

relation identityStayH: Heap => Constraint =
  axiom identityStayH([]) => CONSTRAINT(REQUIRED, VALUE(K(TRUE)))

  rule alert(["IdentityStayHeap\n"],[],[]) &
       identityStayFields(r, o) => (Cf, o') &
       identityStayH(H0) => C0
       --------------------------------
       identityStayH((r, o) :: H0) => COMPOUNDCONSTRAINT(C0,
				 COMPOUNDCONSTRAINT(CONSTRAINT(REQUIRED, COMPARE(DEREF(VALUE(R(r))), EQUAL, VALUE(O(o')))), Cf))
end

relation identityStayFields: (Reference, ObjectLiteral) => (Constraint, ObjectLiteral) =
  axiom identityStayFields(_, []) => (CONSTRAINT(REQUIRED, VALUE(K(TRUE))), [])

  rule identityStayFields(r, rest) => (C, o) &
       int_string(r) => is &string_append(is, "_") => is' & string_append(is', l) => x &
       identityStay([(x, v)]) => C0
       ---------------------------------------------------------------------------------
       identityStayFields(r, (l, VALUE(v)) :: rest) => (COMPOUNDCONSTRAINT(C0, C), (l, LVALUE(VARIABLE(x))) :: o)
end

relation inline: (Env, Scope, Heap, Cstore, Istore, Exp) => (Env, Exp, Exp) =
  axiom inline(E,S,H,C,I,VALUE(K(c))) => (E,VALUE(K(TRUE)),VALUE(K(c)))

  rule	alert(["I-Var"],[],[]) &
	Util.lookupScope(S,x) => xg
	---------------------------
	inline(E,S,H,C,I,LVALUE(VARIABLE(x))) => (E,VALUE(K(TRUE)),LVALUE(VARIABLE(xg)))

  rule	alert(["I-Record"],[],[]) &
	inlineEachField(E,S,H,C,I,o) => (En,ec,o')
	------------------------------------
	inline(E,S,H,C,I,IRECORD(o)) => (En,ec,VALUE(O(o')))

  rule	alert(["I-Record"],[],[]) &
	inlineEachField(E,S,H,C,I,o) => (En,ec,o')
	------------------------------------
	inline(E,S,H,C,I,VALUE(O(o))) => (En,ec,VALUE(O(o')))

  rule	alert(["I-Field"],[],[]) &
	inline(E,S,H,C,I,e) => (E',ec,e') &
	eval(E',S,H,C,I,e) => (E'',H,C,I,R(r))
	---------------------------------------------
	inline(E,S,H,C,I,LVALUE(FIELD(e,l))) => (E',COMBINE(ec,AND,COMPARE(e',EQUAL,VALUE(R(r)))),LVALUE(FIELD(DEREF(e'),l)))

  rule	alert(["I-ValueField"],[],[]) &
	inline(E,S,H,C,I,e) => (E',ec,e') &
	eval(E',S,H,C,I,e) => (E'',H,C,I,O(o))
	---------------------------------------------
	inline(E,S,H,C,I,LVALUE(FIELD(e,l))) => (E',ec,LVALUE(FIELD(e',l)))

  axiom inline(E,S,H,C,I,VALUE(R(r))) => (E,VALUE(K(TRUE)),VALUE(R(r)))

  rule	alert(["I-Op"],[],[]) &
	inline(E,S,H,C,I,e1) => (E',eca,ea) &
	inline(E',S,H,C,I,e2) => (E'',ecb,eb)
	-------------------------------------
	inline(E,S,H,C,I,OP(e1,op,e2)) => (E'',COMBINE(eca,AND,ecb),OP(ea,op,eb))

  rule	alert(["I-Compare"],[],[]) &
	inline(E,S,H,C,I,e1) => (E',eca,ea) &
	inline(E',S,H,C,I,e2) => (E'',ecb,eb)
	-------------------------------------
	inline(E,S,H,C,I,COMPARE(e1,op,e2)) => (E'',COMBINE(eca,AND,ecb),COMPARE(ea,op,eb))

  rule	alert(["I-Combine"],[],[]) &
	inline(E,S,H,C,I,e1) => (E',eca,ea) &
	inline(E',S,H,C,I,e2) => (E'',ecb,eb)
	-------------------------------------
	inline(E,S,H,C,I,COMBINE(e1,op,e2)) => (E'',COMBINE(eca,AND,ecb),COMBINE(ea,op,eb))

  rule	alert(["I-Identity"],[],[]) &
	inline(E,S,H,C,I,e1) => (E',eca,ea) &
	inline(E',S,H,C,I,e2) => (E'',ecb,eb)
	-----------------------------------------------------
	inline(E,S,H,C,I,IDENTITY(e1,e2)) => (E'',COMBINE(eca,AND,ecb),IDENTITY(ea,eb))

  rule	eval(E,S,H,C,I,e) => (E',H,C,I,v) & lookup(v,l) => (argnames,METHOD(s,e)) &
	alert(["I-Call(", l],[],[")"]) &
	enter(E',S,H,C,I,v,argnames,argexps) => (E'',Sm,H,C,I) &
	step(E'',Sm,H,C,I,s) => (E''',S',H',C',I') &
        H' = H & C' = C & I' = I & (* this is just written differently from the paper *)
	eval(E''',S',H,C,I,e) => (E'''',H,C,I,vr)
	-----------------------------------------
	inline(E,S,H,C,I,CALL(e,l,argexps)) => (E'''',VALUE(K(TRUE)),VALUE(vr))

  rule	inline(E,S,H,C,I,e0) => (E',ec0,e0') & eval(E',S,H,C,I,e0) => (E'',H,C,I,v) &
	lookup(v,l) => (argnames,SIMPLE(e)) &
	alert(["I-SimpleCall(", l],[],[")"]) &
	enter(E'',S,H,C,I,v,argnames,argexps) => (E''',Sm,H,C,I) &
	inlineEach(E''',S,H,C,I,argexps) => (En,ecn,inlinedargexps) &
	Util.lookupScope(Sm,"self") => xgself &
	Util.lookupScopeEach(Sm,argnames) => globalargnames &
	Util.pairwiseEqualEach(xgself :: globalargnames, e0' :: inlinedargexps) => argequalities &
	Util.combineEach(argequalities) => ec &
	inline(En,Sm,H,C,I,e) => (En',ecm,e') &
	Util.combineEach([ec0, ec, ecm, ecn]) => eC
	-----------------------------------------
	inline(E,S,H,C,I,CALL(e0,l,argexps)) => (En',eC,e')
end

relation inlineEach: (Env, Scope, Heap, Cstore, Istore, Exp list) => (Env, Exp, Exp list) =
  axiom inlineEach(E,S,H,C,I,[]) => (E,VALUE(K(TRUE)),[])

  rule	inline(E,S,H,C,I,e) => (E',eC,e') &
	inlineEach(E',S,H,C,I,rest) => (E'',restC,rest')
	------------------------------------------------
	inlineEach(E,S,H,C,I,e :: rest) => (E'',COMBINE(eC,AND,restC),e' :: rest')
end

relation inlineEachField: (Env, Scope, Heap, Cstore, Istore, ObjectLiteral) => (Env, Exp, ObjectLiteral) =
  axiom inlineEachField(E,S,H,C,I,[]) => (E,VALUE(K(TRUE)),[])

  rule	inline(E,S,H,C,I,e) => (E',eC,e') &
	inlineEachField(E',S,H,C,I,rest) => (E'',restC,rest')
	------------------------------------------------
	inlineEachField(E,S,H,C,I,(l,e) :: rest) => (E'',COMBINE(eC,AND,restC),(l,e') :: rest')
end

relation reinlineC: (Env, Heap, Istore, Cstore) => (Env, Constraint) =
  axiom reinlineC(E,H,I,[]) => (E,CONSTRAINT(REQUIRED, VALUE(K(TRUE))))

  rule	reinlineC(E,H,I,Cstore0) => (E0,C0) &
	inline(E0,S,H,Cstore0,I,e) => (E',eC,e')
	-----------------------------------------------------------------
	reinlineC(E,H,I,(S,CONSTRAINT(rho,e)) :: Cstore0) => (E',COMPOUNDCONSTRAINT(C0,CONSTRAINT(rho,COMBINE(e',AND,eC))))
end

relation reinlineI: (Env, Heap, Cstore, Istore) => (Env, Constraint) =
  axiom reinlineI(E,H,C,[]) => (E,CONSTRAINT(REQUIRED, VALUE(K(TRUE))))

  rule	reinlineI(E,H,C,Istore0) => (E0,C0) &
	inline(E0,S,H,C,Istore0,e) => (E',eC,e')
	----------------------------------------------------------------------
	reinlineI(E,H,C,(S,CONSTRAINT(REQUIRED,e)) :: Istore0) => (E',COMPOUNDCONSTRAINT(C0,CONSTRAINT(REQUIRED,COMBINE(e',AND,eC))))
end

relation twoPhaseUpdate: (Env, Heap, Cstore, Istore, Exp, Constraint) => (Env, Heap) =
  rule	stay(E) => CEs & stayH(H) => CHs & reinlineI(E,H,C,I) => (Ei,Ci) &
	models(COMPOUNDCONSTRAINT(COMPOUNDCONSTRAINT(COMPOUNDCONSTRAINT(Ci,CEs),C0),
				  COMPOUNDCONSTRAINT(CHs,CONSTRAINT(REQUIRED,COMPARE(e1,EQUAL,e2))))) => (E',H') &
	identityStay(E') => CEs' & identityStayH(H') => CHs' & reinlineC(E',H',I,C) => (Ec,Cc) & welltyped(Ec,H',Cc) &
	models(COMPOUNDCONSTRAINT(COMPOUNDCONSTRAINT(COMPOUNDCONSTRAINT(Cc,C0),
						     COMPOUNDCONSTRAINT(CEs',CHs')),
				  CONSTRAINT(REQUIRED,COMPARE(e1,EQUAL,e2)))) => (E'',H'')
	----------------------------------------------------------------------------------
	twoPhaseUpdate(E,H,C,I,IDENTITY(e1,e2),C0) => (E'',H'')
end

relation step: (Env, Scope, Heap, Cstore, Istore, Statement) => (Env, Scope, Heap, Cstore, Istore) =

  axiom step(E,S,H,C,I,SKIP) => (E,S,H,C,I)

  rule  alert(["S-Seq\n"],[],[]) &
	step(E, S, H, C, I, s1) => (E',S',H',C',I') &
	step(E',S',H',C',I',s2) => (E'',S'',H'',C'',I'')
	------------------------------------------------
	step(E,S,H,C,I,SEQ(s1,s2)) => (E'',S'',H'',C'',I'')

  rule  eval(E,S,H,C,I,e) => (E',H',C',I',K(TRUE)) &
	alert(["S-IfThen\n"],[],[]) &
	step(E',S,H',C',I',s1) => (E'',S',H'',C'',I'')
	----------------------------------------------
	step(E,S,H,C,I,IF(e, s1, s2)) => (E'',S',H'',C'',I'')

  rule  eval(E,S,H,C,I,e) => (E',H',C',I',v) &
	not v = K(TRUE) &
	alert(["S-IfElse\n"],[],[]) &
	step(E',S,H',C',I',s2) => (E'',S',H'',C'',I'')
	----------------------------------------------
	step(E,S,H,C,I,IF(e, s1, s2)) => (E'',S',H'',C'',I'')

  rule  eval(E,S,H,C,I,e) => (E',H',C',I',K(TRUE)) &
	alert(["S-WhileDo\n"],[],[]) &
	step(E',S,H',C',I',s) => (E'',S',H'',C'',I'') &
	step(E'',S',H'',C'',I'', WHILE(e, s)) => (E''',S'',H''',C''',I''')
	------------------------------------------------------------------
	step(E,S,H,C,I,WHILE(e, s)) => (E''',S'',H''',C''',I''')

  rule  eval(E,S,H,C,I,e) => (E',H',C',I',v) &
	not v = K(TRUE) &
	alert(["S-WhileSkip\n"],[],[])
	-----------------------------------------------------
	step(E,S,H,C,I, WHILE(e, s)) => (E',S,H',C',I')

  rule	Util.lookupScope(S,x) => xg & alert(["S-AsgnLocal(",x,")\n"],[],[]) &
	eval(E,S,H,C,I,e) => (E',H',C',I',v) &
	twoPhaseUpdate(E',H',C',I',IDENTITY(LVALUE(VARIABLE(xg)),VALUE(v)),CONSTRAINT(REQUIRED,VALUE(K(TRUE)))) => (E'',H'')
	-----------------------------------------------------------------------------------------------
	step(E,S,H,C,I,ASSIGN(VARIABLE(x),e)) => (E'',S,H'',C',I')

  rule	not Util.lookupScope(S,x) => _ & alert(["S-AsgnNewLocal(",x,") := "],[e],["\n"]) &
	tick() => i & int_string(i) => istring & string_append(x,istring) => xg &
	list_append(S,[(x,xg)]) => S' &
	eval(E,S,H,C,I,e) => (E',H',C',I',v) &
	twoPhaseUpdate(E',H',C',I',IDENTITY(LVALUE(VARIABLE(xg)),VALUE(v)),CONSTRAINT(REQUIRED,VALUE(K(TRUE)))) => (E'',H'')
	-----------------------------------------------------------------------------------------------
	step(E,S,H,C,I,ASSIGN(VARIABLE(x),e)) => (E'',S',H'',C',I')

  rule  alert(["S-AsgnLValue\n"],[],[]) &
	eval(E,S,H,C,I,e) => (E',H',C',I',v) &
	inline(E',S,H',C',I',LVALUE(FIELD(el,l))) => (E'',eC,e') &
	twoPhaseUpdate(E'',H',C',I',IDENTITY(e',VALUE(v)),CONSTRAINT(REQUIRED,eC)) => (E''',H'')
	---------------------------------------------------------------------------------------------
	step(E,S,H,C,I,ASSIGN(FIELD(el,l),e)) => (E''',S,H'',C',I')

  rule  alert(["S-OnceIdentity\n"],[],[]) &
	eval(E,S,H,C,I,e0) => (E0,H,C,I,v0) & eval(E0,S,H,C,I,e1) => (E1,H,C,I,v1) & v0 = v1 &
	inline(E1,S,H,C,I,e0) => (E2,eC0,e0') & inline(E2,S,H,C,I,e1) => (E3,eC1,e1')
	-----------------------------------------------------------------------------
	step(E,S,H,C,I, ONCE(CONSTRAINT(REQUIRED, IDENTITY(e0, e1)))) => (E3,S,H,C,I)

  rule	alert(["S-AlwaysIdentity\n"],[],[]) &
	step(E,S,H,C,I, ONCE(CONSTRAINT(REQUIRED, IDENTITY(e0, e1)))) => (E',S,H,C,I) &
	list_append(I,[(S,CONSTRAINT(REQUIRED, IDENTITY(e0, e1)))]) => I'
	-----------------------------------------------------------------
	step(E,S,H,C,I, ALWAYS(CONSTRAINT(REQUIRED, IDENTITY(e0, e1)))) => (E',S,H,C,I')

  rule	alert(["S-Once\n"],[],[]) &
	inline(E,S,H,C,I,e) => (E',eC,e') &
	welltyped(E',H, CONSTRAINT(rho,COMBINE(e',AND,eC))) &
	identityStay(E') => CEs & identityStayH(H) => CHs &
	reinlineC(E',H,I,C) => (E'', Cc) &
	models(COMPOUNDCONSTRAINT(COMPOUNDCONSTRAINT(CEs, CHs),
				  COMPOUNDCONSTRAINT(Cc, CONSTRAINT(rho,COMBINE(e',AND,eC))))) => (E''',H')
	--------------------------------------------------------------------------------------------------
	step(E,S,H,C,I,ONCE(CONSTRAINT(rho,e))) => (E''',S,H',C,I)

  rule	alert(["S-Always\n"],[],[]) &
	step(E,S,H,C,I, ONCE(C0)) => (E',S,H',C,I) &
	list_append(C,[(S,C0)]) => C'
	---------------------------------------------
	step(E,S,H,C,I, ALWAYS(C0)) => (E',S,H',C',I)
end


(* debugging *)
relation alert: (string list, Exp list, string list) => () =
  axiom alert(_, _, _) => ()

  (* 
   * rule  string_append_list(s1) => s1' & print s1' &
   * 	Print.printE(e) => es & print es &
   * 	string_append_list(s2) => s2' & print s2'
   * 	-----------------------------------------
   * 	alert(s1,e :: _,s2)
   * 
   * rule  string_append_list(s1) => s1' & print s1' &
   *       print "<unprintable>" &
   * 	string_append_list(s2) => s2' & print s2'
   * 	-----------------------------------------
   * 	alert(s1,e :: _,s2)
   * 
   * rule  string_append_list(s1) => s1' & print s1' &
   * 	string_append_list(s2) => s2' & print s2'
   * 	-----------------------------------------
   * 	alert(s1,[],s2)
   *)
end

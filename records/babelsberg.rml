(* file assignment.rml *)

module babelsberg:
(* Abstract syntax for the BabelsbergP language *)

  datatype Program = PROGRAM of Statement

  datatype Statement = SEQ of Statement * Statement
		     | SKIP
		     | ASSIGN of Variable * Exp
		     | ALWAYS of Constraint
		     | ONCE of Constraint
		     | IF of Exp * Statement * Statement
		     | WHILE of Exp * Statement

  datatype Constraint = CONSTRAINT of Rho * Exp
		      | COMPOUNDCONSTRAINT of Constraint * Constraint

  datatype Rho = WEAK | REQUIRED

  datatype Exp = VALUE of Value
	       | VARIABLE of Variable
	       | OP of Exp * Op * Exp
	       | COMPARE of Exp * Comp * Exp
	       | COMBINE of Exp * Comb * Exp
               | RECORD of Fieldexpression list
               | FIELD of Exp * Label

(* Helper types to match a single label:exp pair *)
  datatype Fieldexpression = LABELEXPRESSION of Label * Exp

  datatype Constant = REAL of real | TRUE | FALSE | NIL | STRING of string | IRECORD of Fieldexpression list

  type Variable = string
  type Label = string

  datatype Op =  ADD | SUB | MUL | DIV
  datatype Comp = LESSTHAN | LEQUAL | EQUAL | NEQUAL | GEQUAL | GREATERTHAN
  datatype Comb = AND | OR

(* Values stored in environments *)
  type Value   = Constant

(* Type syntax *)
  datatype Type = PRIMITIVE | TRECORD of Fieldtypes list
  datatype Fieldtypes = LABELTYPE of Label * Type


(* Bindings and environments *)
  type VarBnd      = (Variable * Value)
  type Env         = VarBnd list
  type Cstore      = Constraint

  relation evalprogram: Program => ()
  relation eval: (Env, Exp) => Value
end

relation evalprogram: Program => () =
  rule print "starting to evaluate\n" &
       step([], CONSTRAINT(REQUIRED, VALUE(TRUE)), statement) => (Env, Cstore)
       -------------------------------------
       evalprogram(PROGRAM(statement))
end

relation step: (Env, Cstore, Statement) => (Env, Cstore) =
  rule print "S-Asgn\n" &
       eval(Env,e) => v &
       welltyped(((x, v) :: Env), Cstore) &
       stay(Env) => Cs &
       models(COMPOUNDCONSTRAINT(COMPOUNDCONSTRAINT(Cstore, Cs),
              CONSTRAINT(REQUIRED, COMPARE(VARIABLE(x), EQUAL, VALUE(v))))) => Env'
       ----------------------------------------------
       step(Env, Cstore, ASSIGN(x, e)) => (Env', Cstore)

  rule print "S-Once\n" &
       welltyped(Env, C0) &
       stay(Env) => Cs &
       models(COMPOUNDCONSTRAINT(COMPOUNDCONSTRAINT(Cstore, Cs), C0)) => Env'
       ----------------------------------------
       step(Env, Cstore, ONCE(C0)) => (Env', Cstore)

  rule print "S-Always\n" &
       step(Env, Cstore, ONCE(C0)) => (Env', Cstore)
       ----------------------------------------
       step(Env, Cstore, ALWAYS(C0)) => (Env', COMPOUNDCONSTRAINT(Cstore, C0))

  axiom step(Env, Cstore, SKIP) => (Env, Cstore)

  rule print "S-SeqStep\n" &
       step(Env, Cstore, s1) => (Env', Cstore') &
       step(Env', Cstore', s2) => (Env'', Cstore'')
       --------------------------------------------------
       step(Env, Cstore, SEQ(s1, s2)) => (Env'', Cstore'')

  rule eval(Env, e) => TRUE &
       print "S-IfThen\n" &
       step(Env, Cstore, s1) => (Env', Cstore')
       ----------------------------------------
       step(Env, Cstore, IF(e, s1, s2)) => (Env', Cstore')

  rule eval(Env, e) => v &
       not v = TRUE &
       print "S-IfElse\n" &
       step(Env, Cstore, s2) => (Env', Cstore')
       ----------------------------------------
       step(Env, Cstore, IF(e, s1, s2)) => (Env', Cstore')

  rule eval(Env, e) => TRUE &
       print "S-WhileDo\n" &
       step(Env, Cstore, s) => (Env', Cstore') &
       step(Env', Cstore', WHILE(e, s)) => (Env'', Cstore'')
       -----------------------------------------------------
       step(Env, Cstore, WHILE(e, s)) => (Env'', Cstore'')

  rule eval(Env, e) => v &
       not v = TRUE &
       print "S-WhileSkip\n"
       -----------------------------------------------------
       step(Env, Cstore, WHILE(e, s)) => (Env, Cstore)
end

relation eval: (Env, Exp) => Value =
  axiom eval(_, VALUE(c)) => c

  rule print "E-Var\n" &
       Util.lookupEnv(Env, x) => v
       ----------------------
       eval(Env, VARIABLE(x)) => v

  rule print "E-Op\n" &
       eval(Env, e1) => v1 &
       eval(Env, e2) => v2 &
       Util.apply_binop(op,v1,v2) => v
       ------------------------------
       eval(Env, OP(e1, op, e2)) => v

  rule print "E-Compare\n" &
       eval(Env, e1) => v1 &
       eval(Env, e2) => v2 &
       Util.apply_bincomp(op,v1,v2) => v
       ------------------------------
       eval(Env, COMPARE(e1, op, e2)) => v

  rule eval(Env, e1) => v1 &
       Util.shortcircuit_bincomb(op,v1) => (true, v) &
       print "E-CombineShortCircuit\n"
       ---------------------------------------------
       eval(Env, COMBINE(e1, op, e2)) => v

  rule print "E-Combine\n" &
       eval(Env, e1) => v1 &
       Util.shortcircuit_bincomb(op,v1) => (false, v) &
       eval(Env, e2) => v2 &
       Util.apply_bincomb(op,v1,v2) => v
       ---------------------------------
       eval(Env, COMBINE(e1, op, e2)) => v

  rule print "E-Rec\n" &
       evalFields(Env, fexps) => fvalues
       ---------------------------------
       eval(Env, RECORD(fexps)) => IRECORD(fvalues)

  rule print "E-Field\n" &
       eval(Env, e) => IRECORD(fvalues) &
       Util.lookupRecord(fvalues, l) => v
       ----------------------------------
       eval(Env, FIELD(e, l)) => v
end

relation evalFields: (Env, Fieldexpression list) => (Fieldexpression list) =
(* Helper rules to evaluate the list of fields *)
  axiom evalFields(Env, []) => []

  rule eval(Env, e) => v &
       evalFields(Env, rest) => fvalues &
       list_append([LABELEXPRESSION(l, VALUE(v))], fvalues) => fvalues'
       ----------------------------------------------------------------
       evalFields(Env, LABELEXPRESSION(l, e) :: rest) => fvalues'
end

relation tC: (Env, Exp) => Type =
  axiom tC(_, VALUE(REAL(c))) => PRIMITIVE
  axiom tC(_, VALUE(TRUE)) => PRIMITIVE
  axiom tC(_, VALUE(FALSE)) => PRIMITIVE
  axiom tC(_, VALUE(NIL)) => PRIMITIVE
  axiom tC(_, VALUE(STRING(c))) => PRIMITIVE

  rule print "T-Var\n" &
       eval(Env, VARIABLE(x)) => v &
       tC(Env, VALUE(v)) => T
       -----------------
       tC(Env, VARIABLE(x)) => T

  rule print "T-Op\n" &
       tC(Env, e1) => PRIMITIVE &
       tC(Env, e2) => PRIMITIVE
       --------------------------
       tC(Env, OP(e1, op, e2)) => PRIMITIVE

  rule print "T-Compare\n" &
       tC(Env, e1) => T1 &
       tC(Env, e2) => T2 &
       T1 = T2
       --------------------------
       tC(Env, COMPARE(e1, op, e2)) => PRIMITIVE

  rule print "T-Combine\n" &
       tC(Env, e1) => PRIMITIVE &
       tC(Env, e2) => PRIMITIVE
       --------------------------
       tC(Env, COMBINE(e1, op, e2)) => PRIMITIVE

  rule print "T-Record\n" &
       tCFields(Env, fexps) => ftypes
       ----------------------------
       tC(Env, RECORD(fexps)) => TRECORD(ftypes)

  rule print "T-Record\n" &
       tCFields(Env, fvalues) => ftypes
       ----------------------------
       tC(Env, VALUE(IRECORD(fvalues))) => TRECORD(ftypes)

  rule print "T-Field\n" &
       tC(Env, e) => TRECORD(ftypes) &
       Util.lookupRecordType(ftypes, l) => T
       -------------------------------------
       tC(Env, FIELD(e, l)) => T
       
end    

relation tCFields: (Env, Fieldexpression list) => (Fieldtypes list) =
(* Helper rules to type the list of fields *)
  axiom tCFields(Env, []) => []

  rule tC(Env, e) => T &
       tCFields(Env, rest) => ftypes &
       list_append([LABELTYPE(l, T)], ftypes) => ftypes'
       ----------------------------------------------------------------
       tCFields(Env, LABELEXPRESSION(l, e) :: rest) => ftypes'
end

relation welltyped: (Env, Constraint) => () =
  rule tC(Env, e) => T
       -----------------
       welltyped(Env, CONSTRAINT(rho, e))

  rule welltyped(Env, C1) & welltyped(Env, C2)
       -----------------------------
       welltyped(Env, COMPOUNDCONSTRAINT(C1, C2))
end    

relation stay: Env => Constraint =
  axiom stay([]) => CONSTRAINT(REQUIRED, VALUE(TRUE))

  rule print "StayOne\n" &
       stay(E0) => C0
       --------------------------------
       stay((x, v) :: E0) => COMPOUNDCONSTRAINT(C0, CONSTRAINT(WEAK, COMPARE(VARIABLE(x), EQUAL, VALUE(v))))

end

with "solver.rml"
with "printer.rml"
with "helper.rml"

relation models: Constraint => Env =
  rule Print.printC(C) => Cs &
       Solver.solve(Cs) => El &
       Print.parseEnvironment(El, []) => E &
       print "\n"
       ------------------------------
       models(C) => E
end

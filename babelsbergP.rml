(* file assignment.rml *)

module babelsbergP:
(* Abstract syntax for the BabelsbergP language *)

  datatype Program = PROGRAM of Statement

  datatype Statement = SEQ of Statement * Statement
		     | SKIP
		     | ASSIGN of Variable * Exp
		     | ALWAYS of Constraint
		     | ONCE of Constraint
		     | IF of Exp * Statement * Statement
		     | WHILE of Exp * Statement

  datatype Constraint = CONSTRAINT of Rho * Exp
		      | COMPOUNDCONSTRAINT of Constraint * Constraint

  datatype Rho = WEAK | REQUIRED

  datatype Exp = VALUE of Value
	       | VARIABLE of Variable
	       | OP of Exp * Op * Exp
	       | COMPARE of Exp * Comp * Exp
	       | COMBINE of Exp * Comb * Exp

  datatype Constant = REAL of real | TRUE | FALSE | NIL

  type Variable = string

  datatype Op =  ADD | SUB | MUL | DIV
  datatype Comp = LESSTHAN | LEQUAL | EQUAL | GEQUAL | GREATERTHAN
  datatype Comb = AND

(* Values stored in environments *)
  type Value   = Constant

(* Bindings and environments *)
  type VarBnd      = (Variable * Value)
  type Env         = VarBnd list
  type Cstore      = Constraint

(* Ty2 is an auxiliary datatype used to handle types during evaluation *)
  datatype Ty2     =  REAL2 of real * real

  relation evalprogram: Program => ()
end

relation evalprogram: Program => () =
  rule print "starting to evaluate\n" &
       step([], CONSTRAINT(REQUIRED, VALUE(TRUE)), statement) => (Env, Cstore)
       -------------------------------------
       evalprogram(PROGRAM(statement))
end

relation step: (Env, Cstore, Statement) => (Env, Cstore) =
  rule print "S-Asgn\n" &
       eval(Env,e) => v &
       stay(Env) => Cs &
       models(COMPOUNDCONSTRAINT(COMPOUNDCONSTRAINT(Cstore, Cs), CONSTRAINT(REQUIRED, COMPARE(VARIABLE(x), EQUAL, VALUE(v))))) => Env'
       ----------------------------------------------
       step(Env, Cstore, ASSIGN(x, e)) => (Env', Cstore)

  rule print "S-SeqSkip\n" &
       step(Env, Cstore, s) => (Env', Cstore')
       --------------------------------------------------
       step(Env, Cstore, SEQ(SKIP, s)) => (Env', Cstore')

  rule print "S-SeqStep\n" &
       step(Env, Cstore, s1) => (Env', Cstore') &
       step(Env', Cstore', s2) => (Env'', Cstore'')
       --------------------------------------------------
       step(Env, Cstore, SEQ(s1, s2)) => (Env'', Cstore'')
end

relation eval: (Env, Exp) => Value =
  axiom eval(_, VALUE(c)) => c

  rule print "E-Var\n" &
       Util.lookupEnv(Env, x) => v
       ----------------------
       eval(Env, VARIABLE(x)) => v

  rule print "E-Op\n" &
       eval(Env, e1) => v1 &
       eval(Env, e2) => v2 &
       Util.apply_binop(op,v1,v2) => v
       ------------------------------
       eval(Env, OP(e1, op, e2)) => v

  rule print "E-Compare\n" &
       eval(Env, e1) => v1 &
       eval(Env, e2) => v2 &
       Util.apply_bincomp(op,v1,v2) => v
       ------------------------------
       eval(Env, COMPARE(e1, op, e2)) => v

  rule print "E-Combine\n" &
       eval(Env, e1) => v1 &
       eval(Env, e2) => v2 &
       Util.apply_bincomb(op,v1,v2) => v
       ------------------------------
       eval(Env, COMBINE(e1, op, e2)) => v
end

relation stay: Env => Constraint =
  axiom stay([]) => CONSTRAINT(REQUIRED, VALUE(TRUE))

  rule print "StayOne\n" &
       stay(rest) => C0
       --------------------------------
       stay((x, v) :: rest) => COMPOUNDCONSTRAINT(C0, CONSTRAINT(WEAK, COMPARE(VARIABLE(x), EQUAL, VALUE(v))))

end

with "solver.rml"
with "printer.rml"
with "helper.rml"

relation models: Constraint => Env =
  rule Print.printC(C) => Cs &
       Solver.solve(Cs) => El &
       Print.parseEnvironment(El, []) => E
       ------------------------------
       models(C) => E
end

(*
relation printvalue:(Value) => () =
  rule  int_string(x) => x' &
	print x'
	---------------------
	printvalue(INTval(x))

  rule  real_string(x) => x' &
	print x'
	----------------------
	printvalue(REALval(x))
end (* printvalue *)

relation evals: (Env,Exp list) => Env  =

  axiom evals(e, []) => e

  rule  eval(env, exp) => (env2, _) &
	evals(env2, expl) => env3
	----------------------------
	evals(env, exp::expl) => env3

end

relation eval:  (Env,Exp) => (Env,Value)  =
(* Evaluation of expression exp in current environment env, returning
 * a possibly updated environment, and a value which can be either an
 * integer- or real-typed constant value, tagged with constructors
 * INTval or REALval, respectively *)

  axiom eval(env, INT(ival) ) => (env, INTval(ival))   (* int constant *)

  axiom eval(env,REAL(rval) ) => (env,REALval(rval))  (* real constant *)

  rule  lookupextend(env,id) => (env2,value)
	-----------------------------------            (* variable id *)
	eval(env,IDENT(id)) => (env2,value)

  rule  eval(env,e1)    => (env1,v1) &
	eval(env,e2)    => (env2,v2) &
	type_lub(v1,v2) => INT2(x,y) &
	apply_int_binop(binop,x,y) => z
	--------------------------------             (* int binop int *)
	eval(env, BINARY(e1,binop,e2)) => (env2,INTval(z))

 rule   eval(env,e1)    => (env1,v1) &
	eval(env,e2)    => (env2,v2) &
	type_lub(v1,v2) => REAL2(x,y) &
	apply_real_binop(binop,x,y) => z
	--------------------------------   (* int/real binop int/real *)
	eval(env, BINARY(e1,binop,e2)) => (env2,REALval(z))

  rule  eval(env,e) => (env1,INTval(x))  &
	apply_int_unop(unop,x) => y
	-----------------------------------             (* int unop exp *)
	eval(env, UNARY(unop,e) ) => (env1,INTval(y))

  rule  eval(env,e) => (env1,REALval(x))  &
	apply_real_unop(unop,x) => y
	------------------------------------            (* real unop exp *)
	eval(env, UNARY(unop,e) ) => (env1,REALval(y))

  (* eval of an assignment node returns the updated environment and
   * the assigned value *)
  rule  eval(env,exp) => (env1,value)  &
	update(env1,id,value) => env2
	----------------------------------------        (* id := exp *)
	eval(env, ASSIGN(id,exp)) => (env2,value)

(* Note: there will be no type error if a real value is assigned to an
 * existing integer-typed variable, since the variable will change
 * type when it is updated *)

end (* eval *)

relation type_lub: (Value,Value) => Ty2  =
 axiom  type_lub(INTval(x), INTval(y))   =>  INT2(x,y)

 rule   int_real(x) => x2
	----------------
	type_lub(INTval(x), REALval(y))  =>  REAL2(x2,y)

 rule   int_real(y) => y2
	-----------------
	type_lub(REALval(x),INTval(y))   =>  REAL2(x,y2)

 axiom  type_lub(REALval(x),REALval(y))  =>  REAL2(x,y)
end

relation apply_int_binop: (BinOp,int,int) => int =

 rule   x + y => z
	------------------------                              (* x+y *)
	apply_int_binop(ADD,x,y) => z

 rule   x - y => z
	------------------------                              (* x-y *)
	apply_int_binop(SUB,x,y) => z

 rule   x * y => z
	------------------------                              (* x*y *)
	apply_int_binop(MUL,x,y) => z

 rule   x / y => z
	------------------------                              (* x/y *)
	apply_int_binop(DIV,x,y) => z
end

relation apply_int_unop: (UnOp,int) => int =

 rule   -x => y
	------------------------                              (* -x *)
	apply_int_unop(NEG,x) => y

end (* apply_int_unop *)


relation apply_real_unop: (UnOp,real) => real =

 rule   -. x => y
	------------------------                              (* -x *)
	apply_real_unop(NEG,x) => y

end (* apply_real_unop *)

relation lookup: (Env,Ident) => Value  =
(* lookup returns the value associated with an identifier.
 * If no association is present, lookup will fail. *)

(* Identifier id is found in the first pair of the list, and value
 * is returned. *)
  rule  id = id2
	------------------------------
	lookup((id2,value) :: _, id) => value

(* id is not found in the first pair of the list, and lookup will
 * recursively search the rest of the list. If found, value is returned.
 *)
  rule  not id=id2  &  lookup(rest, id) => value
	-------------------------------------
	lookup((id2,_) :: rest, id)  => value
end (* lookup *)

relation lookupextend: (Env,Ident) => (Env,Value)  =
(* Return value of id in env. If id not present, add id and return 0 *)

  rule  not lookup(env,id) => v &
	let value = INTval(0)
	-----------------------------
	lookupextend(env, id) => ((id, value)::env,value)

  rule  lookup(env,id) => value
	--------------------------------
	lookupextend(env, id)  => (env,value)
end (* lookupextend *)

relation update: (Env,Ident,Value) => Env  =
(* Store binding of id to value at front of environment env *)

  axiom update(env,id,value) => ((id,value) :: env)

end (* update *)

*)
